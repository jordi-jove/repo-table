{"ast":null,"code":"var _a = Object.prototype,\n    toString = _a.toString,\n    hasOwnProperty = _a.hasOwnProperty;\n/**\r\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\r\n */\n\nfunction equal(a, b) {\n  // Emptying aStack and bStack should never really be necessary, since pushing\n  // and popping is always balanced in withCycleGuard, but it never hurts to\n  // make absolutely sure.\n  aStack.length = bStack.length = 0;\n  return check(a, b);\n} // These stacks are used to detect cyclic references while traversing objects.\n// They can be declared here because they always end up empty again after the\n// traversal is complete (even if an exception was thrown).\n\n\nvar aStack = [];\nvar bStack = [];\n\nfunction check(a, b) {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  } // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n\n\n  var aTag = toString.call(a);\n  var bTag = toString.call(b); // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n    // Fall through to object case...\n\n    case '[object Object]':\n      return withCycleGuard(a, b, checkObject);\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n    // Fall through to shared +a === +b case...\n\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == \"\" + b;\n\n    case '[object Map]':\n    case '[object Set]':\n      {\n        if (a.size !== b.size) return false;\n        return withCycleGuard(a, b, checkMapOrSet);\n      }\n  } // Otherwise the values are not equal.\n\n\n  return false;\n}\n\nfunction withCycleGuard(a, b, callback) {\n  // Although we may detect cycles at different depths along the same\n  // path, once the first object enters a cycle of length N, every nested\n  // child of that object will also be identical to its Nth ancestor, so\n  // we can safely keep recursing until the other object enters a cycle of\n  // length M. If the other object does not have a cycle in this subtree,\n  // the recursion will terminate normally, and equal(a, b) will return\n  // false. If the other object has a cycle, and N === M, we consider the\n  // cycles equivalent. If N !== M, there's a chance the cycles are\n  // somehow isomorphic, but as a matter of policy we say they are not the\n  // same because their structures are, in fact, different.\n  var aIndex = aStack.lastIndexOf(a);\n\n  if (aIndex >= 0) {\n    var bIndex = bStack.lastIndexOf(b);\n\n    if (bIndex >= 0) {\n      return aIndex === bIndex;\n    }\n  }\n\n  aStack.push(a);\n  bStack.push(b);\n\n  try {\n    return callback(a, b);\n  } finally {\n    aStack.pop();\n    bStack.pop();\n  }\n}\n\nfunction checkObject(a, b) {\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b); // If `a` and `b` have a different number of enumerable keys, they\n  // must be different.\n\n  var keyCount = aKeys.length;\n  if (keyCount !== bKeys.length) return false; // Now make sure they have the same keys.\n\n  for (var k = 0; k < keyCount; ++k) {\n    if (!hasOwnProperty.call(b, aKeys[k])) {\n      return false;\n    }\n  } // Finally, check deep equality of all child properties.\n\n\n  for (var k = 0; k < keyCount; ++k) {\n    var key = aKeys[k];\n\n    if (!check(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction checkMapOrSet(a, b) {\n  var aIterator = a.entries();\n  var isMap = b instanceof Map;\n\n  while (true) {\n    var info = aIterator.next();\n    if (info.done) break; // If a instanceof Set, aValue === aKey.\n\n    var _a = info.value,\n        aKey = _a[0],\n        aValue = _a[1]; // So this works the same way for both Set and Map.\n\n    if (!b.has(aKey)) {\n      return false;\n    } // However, we care about deep equality of values only when dealing\n    // with Map structures.\n\n\n    if (isMap && !check(aValue, b.get(aKey))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport default equal;\nexport { equal };","map":null,"metadata":{},"sourceType":"module"}